/// @file sys.h
/// @brief Содержит описания классов, которые реализуют аппаратную часть PAC.
/// 
/// @author  Иванюк Дмитрий Сергеевич.
///
/// @par Описание директив препроцессора:
/// @c DEBUG    - компиляция c выводом отладочной информации в консоль.@n@n
///
/// @c WIN32    - компиляция для OS Windows.@n
/// @c PAC_W750 - компиляция для PAC Wago 750.@n
/// @c I7186_E  - компиляция для PAC I7186_E. Данные директивы определяют
/// специфичную для платформы реализацию работы с консолью, куда выводятся
/// сообщения об ошибках в отладочном режиме.
/// 
/// @par Текущая версия:
/// @$Rev$.\n
/// @$Author$.\n
/// @$Date::                     $.

#ifndef SYS_H
#define SYS_H

typedef unsigned char           u_char;
typedef unsigned int            u_int;
typedef unsigned long int       u_long;

#include <string.h>
#include <stdio.h>

#include "util.h"
//-----------------------------------------------------------------------------
#ifdef DEBUG
/// @brief Проверка нажатия клавиши.
///
/// @return 0 - нет нажатий клавиш.
/// @return 1 - нажата клавиша.
int  kbhit();

/// @brief Считывание нажатого символа с консоли.
///
/// @return - символ нажатой клавиши.
int  get_char();

/// @brief Вывод числа в консоль в двоичном виде.
///
/// @param с - выводимое число.
void print_binary( u_int c );
#endif // DEBUG
//-----------------------------------------------------------------------------
#if defined LINUX || defined UCLINUX
#include <time.h>

#define print_time printf( "%02lu:%02lu:%02lu ", ( time( 0 ) / 3600 ) % 24, \
    ( time( 0 ) / 60 ) % 60, time( 0 ) % 60 ); printf

#define Print printf

#endif // defined LINUX || defined UCLINUX
//-----------------------------------------------------------------------------
/// @brief Получение текущего времени в секундах.
///
/// @return Текущее время (секунды с 01.01.1970, в 2038 произойдет переполнение).
u_long get_sec();
//-----------------------------------------------------------------------------
/// @brief Получение времени в миллисекундах.
///
/// Так как за 4 дня происходит переполнение и отсчет продолжается с 0, то для
/// вычисления разности времени использовать @ref get_delta_millisec.
///
/// @return Время с момента запуска программы в мииллисекундах.
u_long get_millisec();
//-----------------------------------------------------------------------------
/// @brief Получение разности времени в миллисекундах.
///
/// @param time1     - начальное время.
/// @return Разность времени в миллисекундах.
u_long get_delta_millisec( u_long time1 );
//-----------------------------------------------------------------------------
/// @brief Интерфейс доступа к памяти.
class i_memory
    {
    public:
        /// @brief Чтение массива байт.
        ///        
        /// @param buf       - адрес буфера, куда будут считываться данные.
        /// @param count     - количество считываемых байт.
        /// @param start_pos - стартовый адрес.
        ///
        /// @return <  0 - ошибка.
        /// @return >= 0 - количество считанных байт.
        virtual int read( void *buf, u_int count, u_int start_pos ) = 0;

        /// @brief Запись массива байт.
        ///        
        /// @param buf       - адрес буфера, куда будут записываться данные.
        /// @param count     - количество считываемых байт.
        /// @param start_pos - стартовый адрес.
        ///
        /// @return <  0 - ошибка.
        /// @return >= 0 - количество записанных байт.
        virtual int write( void *buf, u_int count, u_int start_pos ) = 0;

        /// @brief Получение размера памяти в байтах.
        ///        
        /// @return - размер памяти в байтах.
        virtual u_int get_size() const = 0;
    };
//-----------------------------------------------------------------------------
/// @brief Работа напрямую с энергонезависимой ОЗУ. Представляет абстракцию от 
/// аппаратной реализации памяти.
class NV_memory : public i_memory
    {  

    public:
        /// @param total_size           - общий размер памяти.
        /// @param available_start_pos  - начальный доступный адрес.
        /// @param available_end_pos    - конечный доступный адрес.
        NV_memory( u_int total_size, u_int available_start_pos, 
            u_int available_end_pos );

        /// @brief Метод интерфейса @ref i_memory.
        u_int get_size() const
            {
            return total_size;
            }

        /// @brief Получение начального доступного для работы адреса памяти.
        ///        
        /// @return - начальный доступный для работы адрес памяти.
        u_int get_available_start_pos() const
            {
            return available_start_pos;
            }

        /// @brief Получение конечного доступного для работы адреса памяти.
        ///        
        /// @return - конечный доступный для работы адрес памяти.
        u_int get_available_end_pos() const
            {
            return available_end_pos;
            }

    private:

        u_int total_size;           ///< Общий размер памяти.

        /// @brief Начальный доступный адрес.
        /// @details Для пропуска зарезервированной системной области.
        u_int available_start_pos;      

        /// @brief Конечный доступный адрес.
        /// @details Для пропуска зарезервированной системной области.
        u_int available_end_pos;        
    };
//-----------------------------------------------------------------------------
/// @brief Работа с блоком памяти.
class memory_range: public i_memory
    {
    friend class NV_memory_manager;

    public:
        /// @brief Метод интерфейса @ref i_memory.
        u_int get_size() const
            {
            return size;
            }

        /// @brief Метод интерфейса @ref i_memory.
        int read( void *buf, u_int count, u_int start_pos );

        /// @brief Метод интерфейса @ref i_memory.
        int write( void *buf, u_int count, u_int start_pos );

    private:
        i_memory    *memory;    ///< Указатель на объект памяти.
        u_int       start_pos;  ///< Начальный адрес.
        u_int       size;       ///< Размер блока памяти в байтах.

        /// @brief Закрытый конструктор.
        ///
        /// Создание объектов осуществляется через метод get_memory_block
        /// класса @ref NV_memory_manager.
        memory_range( i_memory *memory, u_int start_pos, u_int size );

        /// @brief Проверка на корректность параметров.
        ///
        /// @return - результат проверки
        ///    0 - Ок.
        ///    1 - Ошибка.
        int check_params( u_int count, u_int start_pos );
    };
//-----------------------------------------------------------------------------
/// @brief Работа с энергонезависимой ОЗУ. Представляет абстракцию от 
/// физического распределения памяти.
class NV_memory_manager
    {
    public:        
        enum MEMORY_TYPE ///< Типы энергонезависимой памяти.
            {
            MT_NVRAM,
            MT_EEPROM
            };

        /// @brief Получение объекта для работы с блоком памяти.
        ///        
        /// @param m_type - тип памяти, откуда будет выделятся память.
        /// @param count  - размер в байтах.
        ///
        /// @return =  0 - ошибка.
        /// @return >  0 - указатель на объект выделенного блока памяти.
        virtual memory_range* get_memory_block( MEMORY_TYPE m_type,
            u_int count );

        /// @brief Получение единственного экземпляра класса для работы с 
        /// параметрами.
        ///
        /// @return - указатель на единственный объект класса @ref
        /// NV_memory_manager.
        static NV_memory_manager* get_instance();

        /// @brief Установка единственного экземпляра класса для работы с 
        /// параметрами.
        ///
        /// @param new_instance - новый указатель на единственный объект 
        /// класса @ref NV_memory_manager.
        static void set_instance( NV_memory_manager* new_instance );

        virtual ~NV_memory_manager();

    protected:
        /// Статический экземпляр класса для вызова методов.
        static auto_smart_ptr < NV_memory_manager > instance;

        NV_memory_manager();

        /// @brief Работа с энергонезависимой ОЗУ (non-volatile random access 
        /// memory).
        ///
        /// Данная память питается от батарейки, не имеет ограничений на  
        /// количество циклов записи/чтения.
        NV_memory *PAC_NVRAM;

        /// @brief Работа с энергонезависимой ОЗУ (Electrically Erasable 
        /// Programmable Read-Only Memory).
        ///
        /// Имеет ограничения на количество циклов записи/чтения - 1 миллион.
        NV_memory *PAC_EEPROM;

        u_int last_NVRAM_pos;  ///< Индекс крайнего свободного элемента NVRAM.
        u_int last_EEPROM_pos; ///< Индекс крайнего свободного элемента EEPROM.
    };
//-----------------------------------------------------------------------------
/// @brief Работа с объектом файловой системы. Представляет абстракцию от 
/// физической реализации таковой.
class file
    {
    public:
        /// @brief Открытие файла.
        ///
        /// @param file_name - имя файла. 
        ///
        /// @return - результат 
        ///    0   - Ок.
        ///    0 < - Ошибка.
        virtual int fopen( const char *file_name ) = 0;

        /// @brief Чтение из файла блока данных.
        ///
        /// @param buffer - буфер, куда поместить результат. 
        /// @param count - количество считываемых байт. 
        ///
        /// @return - количество считанных байт. 
        virtual int fread( void *buffer, int count ) = 0;

        /// @brief Чтение из файла строки.
        ///
        /// @return - указатель на начало строки. 
        virtual char* fget_line() = 0;

        /// @brief Чтение из файла строки без изменения позиции указателя в 
        /// файле.
        ///
        /// @return - указатель на начало строки. 
        virtual char* pfget_line() = 0;

        /// @brief Закрытие файла.
        ///
        /// @return - результат 
        ///    0   - Ок.
        ///    0 < - Ошибка.
        virtual void fclose() = 0;
    };
//-----------------------------------------------------------------------------
/// @brief Работа с диодными индикаторами. Представляет абстракцию от
/// физической реализации таковых.
class led
    {
    public:
        enum COLOUR
            {
            C_GREEN = 1,
            C_YELLOW,
            C_RED
            };

        enum LEDS_NAMES
            {
            L_ALL = 1,
            L_STATUS,
            L_SERVICE,
            L_USER
            };

        /// @brief Включить диодный индикатор.
        ///
        /// @param led       - диод.
        /// @param led_color - цвет.
        virtual void on( LEDS_NAMES led, COLOUR led_color ) = 0;

        /// @brief Выключить диодный индикатор.
        virtual void off( LEDS_NAMES led ) = 0;

        /// @brief Включить мигание диодного индикатора.
        ///
        /// @param led       - диод.
        /// @param led_color - цвет.
        virtual void blink( LEDS_NAMES led, COLOUR led_color ) = 0;
    };
//-----------------------------------------------------------------------------
#endif // SYS_H
