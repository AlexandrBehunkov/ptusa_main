/// @file PAC_dev.pkg
/// @brief Классы и функции, доступные в Lua.
///
/// @par Текущая версия:
/// @$Rev$.\n
/// @$Author$.\n
/// @$Date::                     $.

$#include <stdlib.h>

$#include "PAC_dev.h"
$#include "tech_def.h"
$#include "wago.h"
$#include "tolua_base.h"
$#include "PID.h"
$#include "g_device.h"

//-----------------------------------------------------------------------------
/// @brief Устройство на основе дискретного входа.
///
/// Обратная связь, предельный уровень и т.д. являются примерами таких
/// устройств.
class i_DI_device
    {
    public:
        /// @brief Получение текущего состояния устройства.
        ///
        /// @return - текущее состояние устройства в виде целого числа.
        int get_state_now();

        /// @brief Получение отфильтрованного состояния устройства.
        ///
        /// Устройство меняет свое состояние, если дискретный вход находится в
        /// в данном состоянии больше заданного интервала времени (Задание
        /// интервала - смотри @ref set_change_time).
        ///
        /// @return - cостояние устройства в виде целого числа.
        int get_state();

        /// @brief Установка интервала времени изменения состояния.
        ///
        /// @param time - интервал времени изменения состояния.
        void set_change_time( unsigned int time );

        /// @brief Установка состояния.
        ///
        /// Данный метод используется для задания состояния устройства перед
        /// его проверкой.
        ///
        /// @param new_state - новое состояние.
        void set_state( int new_state );

        // @brief Получение логического активного состояния устройства.
        bool is_active();
    };
//-----------------------------------------------------------------------------
/// @brief Устройство на основе дискретного выхода.
///
/// Клапан, мешалка и т.д. являются примерами таких устройств.
class i_DO_device: public i_DI_device
    {
    public:
        /// @brief Включение устройства.
        ///
        /// Установка устройства в активное состояние. Для клапана это означает
        /// его активирование, то есть если он нормально закрытый - открытие.
        void on();

        /// @brief Выключение устройства.
        ///
        /// Установка устройства в пассивное состояние. Для клапана это означает
        /// его деактивирование, то есть если он нормально закрытый - закрытие.
        void off();

        /// @brief Установка нового состояния устройства.
        ///
        /// @param new_state - новое состояние объекта.
        void set_state( int new_state );
    };
//-----------------------------------------------------------------------------
/// @brief Устройство на на основе аналогового входа.
///
/// Температура, расход и т.д. являются примерами таких устройств.
class i_AI_device
    {
    public:
        /// @brief Получение текущего состояния устройства.
        ///
        /// @return - текущее состояние устройства в виде дробного числа.
        float get_value();
    };
//-----------------------------------------------------------------------------
/// @brief Устройство на основе аналогового выхода.
///
/// Аналоговый канал управления и т.д. являются примерами таких устройств.
class i_AO_device: public i_AI_device
    {
    public:
        /// @brief Выключение устройства.
        ///
        /// Установка устройства в пассивное состояние. Для клапана это означает
        /// его деактивирование, то есть если он нормально закрытый - закрытие.
        void off();

        /// @brief Установка текущего состояния устройства.
        ///
        /// @param new_value - новое состояние устройства.
        void set_value( float new_value );
    };
//-----------------------------------------------------------------------------
/// @brief Интерфейс счетчика.
class i_counter
    {
    public:
        /// @brief Приостановка работы счетчика.
        void pause();

        /// @brief Возобновление работы счетчика.
        void start();

        /// @brief Сброс счетчика.
        ///
        /// После сброса для продолжения работы необходимо вызвать @ref start().
        void reset();

        /// @brief Сброс счетчика и продолжение счета.
        void restart();

        /// @brief Получение значения счетчика.
        unsigned long get_quantity();
    };
//-----------------------------------------------------------------------------
/// @brief Простое физическое устройство.
///
/// Примеры таких устройств: клапан, насос, мешалка и т.д.
class device
    {
    public:
        /// @brief Выполнение команды устройством.
        ///
        /// Для обработки команд, полученных от сервера.
        int set_cmd( const char *prop, unsigned int idx, double val );

        /// @brief Типы физических устройств.
        ///
        /// Устройства, которые могут быть в проекте. При выполнении режимов,
        /// над ними можно как совершать какие-либо действия (включить\
        /// выключить и т.д.), так и считывать их состояние (значение выхода
        /// и т.д.).
        enum DEVICE_TYPE
            {
            DT_NONE = -1,      ///< Тип не определен.

            DT_V = 0,   ///< Клапан.
            DT_N,       ///< Насос.
            DT_M,       ///< Мешалка.
            DT_LS,      ///< Уровень (есть/нет).
            DT_TE,      ///< Температура.
            DT_FE,      ///< Расход (значение).
            DT_FS,      ///< Расход (есть/нет).
            DT_CTR,     ///< Счетчик.
            DT_AO,      ///< Аналоговый выход.
            DT_LE,      ///< Уровень (значение).
            DT_FB,      ///< Обратная связь.
            DT_UPR,     ///< Канал управления.
            DT_QE,      ///< Концентрация.
            DT_AI,      ///< Аналоговый вход.
            };
    };
//-----------------------------------------------------------------------------
/// @brief Получение клапана по номеру.
///
/// @param number - номер клапана.
/// @return - клапан с заданным номером. Если нет такого клапана, возвращается
/// заглушка (@ref dev_stub).
i_DO_device* V( int number );
//-----------------------------------------------------------------------------
/// @brief Получение насоса по номеру.
///
/// @param number - номер насоса.
/// @return - насос с заданным номером. Если нет такого насоса, возвращается
/// заглушка (@ref dev_stub).
i_DO_device* N( int number );
//-----------------------------------------------------------------------------
/// @brief Получение мешалки по номеру.
///
/// @param number - номер мешалки.
/// @return - мешалка с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_DO_device* M( int number );
//-----------------------------------------------------------------------------
/// @brief Получение сигнального уровня по номеру.
///
/// @param number - номер сигнального уровня.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_DI_device* LS( int number );
//-----------------------------------------------------------------------------
/// @brief Получение сигнального расхода по номеру.
///
/// @param number - номер сигнального расхода.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_DI_device* FS( int number );
//-----------------------------------------------------------------------------
/// @brief Получение аналогового входа по номеру.
///
/// @param number - номер аналогового входа.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_AI_device* AI( int number );
//-----------------------------------------------------------------------------
/// @brief Получение аналогового выхода по номеру.
///
/// @param number - номер аналогового выхода.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_AO_device* AO( int number );
//-----------------------------------------------------------------------------
/// @brief Получение счетчика по номеру.
///
/// @param number - номер счетчика.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_counter* CTR( int number );
//-----------------------------------------------------------------------------
/// @brief Получение температуры по номеру.
///
/// @param number - номер температуры.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_AI_device* TE( int number );
//-----------------------------------------------------------------------------
/// @brief Получение текущего расхода по номеру.
///
/// @param number - номер текущего расхода.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_AI_device* FE( int number );
//-----------------------------------------------------------------------------
/// @brief Получение текущего уровня по номеру.
///
/// @param number - номер текущего уровня.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_AI_device* LE( int number );
//-----------------------------------------------------------------------------
/// @brief Получение обратной связи по номеру.
///
/// @param number - номер обратной связи.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_DI_device* FB( int number );
//-----------------------------------------------------------------------------
/// @brief Получение канала управления по номеру.
///
/// @param number - номер канала управления.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_DO_device* UPR( int number );
//-----------------------------------------------------------------------------
/// @brief Получение текущей концентрации по номеру.
///
/// @param number - номер текущей концентрации.
/// @return - устройство с заданным номером. Если нет такого устройства,
/// возвращается заглушка (@ref dev_stub).
i_AI_device* QE( int number );
//-----------------------------------------------------------------------------
/// @brief Получение насоса по номеру.
///
/// @return - виртуальное устройство.
dev_stub* STUB();
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/// @brief Виртуальное устройство.
///
/// Необходимо для возвращения результата поиска устройства с несуществующим
/// номером. Методы данного класса ничего не делают.
class dev_stub
    {
    public:
        /// @brief Получение состояния устройства.
        ///
        /// @return 0
        float get_value();

        /// @brief Установка состояния устройства. Ничего не делает.
        void set_value( float new_value );


        /// @brief Включение устройства. Ничего не делает.
        void on();

        /// @brief Выключение устройства. Ничего не делает.
        void off();


        /// @brief Установка состояния устройства. Ничего не делает.
        void set_state( int new_state );

        /// @brief Получение состояния устройства.
        ///
        /// @return 0
        int get_state();

        /// @brief Получение текущего состояния устройства.
        ///
        /// @return 0
        int get_state_now();


        /// @brief Остановка счетчика. Ничего не делает.
        void pause();

        /// @brief Возобновление счетчика. Ничего не делает.
        void start();

        /// @brief Сброс счетчика. Ничего не делает.
        void reset();

        /// @brief Получение значения счетчика.
        ///
        /// @return 0
        unsigned int get_quantity();
    };
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/// @brief Интерфейс mixproof.
class i_mix_proof 
    {
    public:
        enum STATES
            {
            ST_CLOSE = 0,   ///< Закрыт.
            ST_OPEN,        ///< Открыт.
            ST_UPPER_SEAT,  ///< Открыть верхнее седло.
            ST_LOWER_SEAT,  ///< Открыть нижнее седло.
            };      
    };
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/// @brief Работа с технологическим объектом.
///
/// Базовый класс для технологического объекта (танка, гребенки). Содержит
/// основные методы работы - работа с режимами и т.д.
class tech_object
    {
    public:
        int set_cmd( const char *prop, unsigned int idx, double val );

        /// @param name                  - название (TANK, COMB).
        /// @param number                - номер.
        /// @param states_count          - количество режимов.
        /// @param timers_count          - количество таймеров.
        /// @param par_float_count       - кол-во сохраняемых пар-ров типа float.
        /// @param runtime_par_float_count - кол-во рабочих пар-ров типа float.
        /// @param par_uint_count         - кол-во сохраняемых пар-ров типа uint.
        /// @param runtime_par_uint_count - кол-во рабочих параметров типа uint.
        tech_object( const char* name = "tech_object", unsigned int number = 0,
            unsigned int states_count = 1,
            unsigned int timers_count = 3,
            unsigned int par_float_count = 5,
            unsigned int runtime_par_float_count = 5,
            unsigned int par_uint_count = 5,
            unsigned int runtime_par_uint_count = 5 );

        ~tech_object();

        /// @brief Включение/выключение режима.
        ///
        /// @param mode      - режим.
        /// @param new_state - новое состояние режима. Принимает значения: 0 -
        /// выключить, 1 - включить, -1 - выключить без проверки на возможность
        ///	отключения.
        int set_mode( unsigned int mode, int new_state );

        /// @brief Получение состояния режима.
        ///
        /// @param mode - режим.
        ///
        /// @return 1 - режим включен.
        /// @return 0 - режим не включен.
        int get_mode( unsigned int mode );

        /// @brief Выполнение команды.
        ///
        /// Здесь могут выполняться какие-либо действия (включаться/выключаться
        /// другие режимы, включаться/выключаться какие-либо устройства).
        int exec_cmd( unsigned int cmd );

        /// @brief Получение числа режимов технологического объекта.
        ///
        /// Здесь могут выполняться какие-либо действия (включаться/выключаться
        /// другие режимы, включаться/выключаться какие-либо устройства).
        unsigned int get_modes_count() const;

        saved_params_float      par_float;   ///< Сохраняемые пар-ры, тип float.
        run_time_params_float   rt_par_float;///< Рабочие параметры, тип float.
        saved_params_u_int_4    par_uint;    ///< Сохраняемые пар-ры, тип uint.
        run_time_params_u_int_4 rt_par_uint; ///< Рабочие пар-ры, тип uint.

        timer_manager           timers;		 ///< Таймеры объекта.

        mode_manager* get_modes_manager();
    };
//-----------------------------------------------------------------------------
///@brief Получение менеджера технологических объектов.
///
///@return Менеджер технологических объектов проекта.
tech_object_manager* G_TECH_OBJECT_MNGR();
//-----------------------------------------------------------------------------
/// @brief Менеджер технологических объектов.
///
/// Содержит информацию обо всех технологических объектах проекта.
class tech_object_manager
    {
    public:
        /// @brief Получение объекта с заданным активным режимом.
        int get_object_with_active_mode( unsigned int mode,
            unsigned int start_idx, unsigned int end_idx );

        /// @brief Получение технологического объекта по его порядковому номеру.
        tech_object* get_tech_objects( unsigned int idx );

        /// @brief Отладочная печать объекта.
        void print();
    };
//-----------------------------------------------------------------------------
/// @brief Менеджер режимов технологического объекта.
///
/// Содержит информацию обо всех режимах объекта. Режим - может быть активным
/// (включен) либо неактивным (выключен). В режиме могут включаться/выключаться
/// устройства и т.д. У объекта может быть активно одновременно несколько
/// режимов. Режим может содержать в себе шаги - при этом у режма в один момент
/// времени может быть активным только один шаг.
class mode_manager
    {
    public:

        /// @brief Устанавливает количество шагов для режима.
        ///
        /// @return < 0 - ошибка.
        /// @return   0 - ок.
        int set_mode_config( unsigned int mode, unsigned char new_steps_cnt );


        /// @brief Переход к шагу.
        ///
        /// @param [in] mode     - режим.
        /// @param [in] new_step - шаг, диапазон 0..255.
        ///
        /// @return < 0 - ошибка.
        /// @return   0 - ок.
        int to_step( unsigned int mode, unsigned char new_step );


        /// @brief Добавление закрываемое устройство для шага.
        ///
        /// @param [in] mode - режим;
        /// @param [in] step - шаг, диапазон 0..255.
        /// @param [in] dev  - указатель на закрываемое устройство.
        ///
        /// @return < 0 - ошибка.
        /// @return   0 - ок.
        int add_closed_dev( unsigned int mode, unsigned char step, device *dev );

        /// @brief Добавление открываемое устройство для шага.
        ///
        /// @param [in] mode - режим.
        /// @param [in] step - шаг, диапазон 0..255.
        /// @param [in] dev  - указатель на открываемое устройство.
        ///
        /// @return < 0 - ошибка.
        /// @return   0 - ок.
        int add_opened_dev( unsigned int mode, unsigned char step, device *dev );

        /// @brief Добавление закрываемое устройство для режима.
        ///
        /// @param [in] mode - режим;
        /// @param [in] dev  - указатель на закрываемое устройство.
        ///
        /// @return < 0 - ошибка.
        /// @return   0 - ок.
        int add_mode_closed_dev( unsigned int mode, device *dev );

        /// @brief Добавление открываемое устройство для режима.
        ///
        /// @param [in] mode - режим.
        /// @param [in] dev  - указатель на открываемое устройство.
        ///
        /// @return < 0 - ошибка.
        /// @return   0 - ок.
        int add_mode_opened_dev( unsigned int mode, device *dev );

        /// @brief Проверка времени выполнения шага.
        ///
        /// @return  < 0 - ошибка.
        /// @return    0 - время не вышло.
        /// @return    1 - время вышло.
        int is_current_step_evaluation_time_left( unsigned int mode );

        /// @brief Время выполнения шага.
        ///
        /// @return    1 - время выполнения шага.
        unsigned long get_current_step_evaluation_time( unsigned int mode );

        /// @brief Время выполнения режима.
        ///
        /// @param [in] mode - режим.
        ///
        /// @return - время выполнения режима.
        unsigned long get_mode_evaluation_time( unsigned int mode );

        /// @brief Время бездействия (нет включенных режимов).
        ///
        /// @return - время системы без активных режимов.
        unsigned long get_idle_time();

        /// @brief Получение активного шага заданного режима.
        ///
        /// @return - активный шаг режима.
        unsigned int get_active_step( unsigned int mode );

        /// @brief Отладочный вывод объекта в консоль.
        void print();

        /// @brief Добавление проверяемой обратной связи при включении режима.
        ///
        /// @param [in] mode - режим;
        /// @param [in] dev  - указатель на проверяемую обратную связь.
        ///
        /// @return < 0 - ошибка.
        /// @return   0 - ок.
        int add_mode_on_FB( unsigned int mode, device *dev );
         

        /// @brief Добавление группы устройств, которые включается\открывается во
        /// время выполнения шага по управляющему сигналу (обратной связи).
        ///        
        /// @param [in] mode           - режим.
        /// @param [in] control_FB_dev - указатель на управляющий сигнал.
        ///
        /// @return >= 0 - номер добавленной группы устройств (для дальнейшего
        /// добавления устройств используется @ref add_mode_pair_dev).
        int add_mode_FB_group( int mode, device *control_FB_dev );

        /// @brief Добавление устройства, которое включается\открывается во
        /// время выполнения шага по управляющему сигналу (обратной связи).
        ///
        /// @param [in] mode     - режим.
        /// @param [in] pair_n   - номер группы устройств.
        /// @param [in] open_dev - указатель на добавляемое устройство.
        ///
        /// @return < 0 - ошибка.
        /// @return   0 - ок.
        int add_mode_pair_dev( int mode, unsigned int pair_n, device *open_dev );


        /// @brief Добавление группы клапанов, промывка седел.
        ///
        /// @param [in] mode  - режим.
		/// @param [in] step  - шаг.
        /// @param [in] state - команда (открытие верхнего\нижнего седла).
        int add_wash_seats_valves_group( int mode, unsigned char step, 
			i_mix_proof::STATES state );

        /// @brief Добавление клапана, промывка седла.
        ///
        /// @param [in] mode  - режим.
		/// @param [in] step  - шаг.
        /// @param [in] group - группа.
        /// @param [in] v     - клапан.
        int add_wash_seat_valve( int mode, unsigned char step, 
			unsigned int group, device *v );
    };
//-----------------------------------------------------------------------------
///@brief Получение менеджера устройств.
///
///@return Менеджер устройств проекта.
device_manager* G_DEVICE_MANAGER();

///@brief Получение технологического объекта по номеру.
///
///@return Технологический объект.
tech_object* G_TECH_OBJECTS( unsigned int idx );
//-----------------------------------------------------------------------------
/// @brief Менеджер устройств.
///
/// Содержит информацию обо всех устройствах проекта.
class device_manager
    {
    public:
        /// @brief Отладочная печать объекта в консоль.
        void print() const;

        // @brief Установка числа устройств.
        //
        // Вызывается из Lua.
        wago_device* add_wago_device( int dev_type, int dev_sub_type,
            unsigned int number, char * descr );

        /// @brief Получение устройства по его номеру.
        device* get_device( device::DEVICE_TYPE dev_type,
            unsigned int dev_number );
    };
//-----------------------------------------------------------------------------
/// @brief Устройство на основе модулей ввода/вывода WAGO.
///
/// В общем случае у устройства может быть один или несколько каналов
/// ввода/вывода (дискретных или аналоговых).
class wago_device
    {
    public:
        // Lua.
        void init( int DO_count, int DI_count,
            int AO_count, int AI_count, int par_count );

        void init_channel( int type, int ch_inex, int node, int offset );

        void init_par( unsigned int index, float value );
    };
//-----------------------------------------------------------------------------
/// @brief Группа таймеров.
class timer_manager
    {
    public:
        /// @brief Безопасное получение таймера по индексу.
        ///
        /// @param index - индекс таймера.
        ///
        /// @return - таймер с нужным индексом, заглушка - в случае выхода за
        /// диапазон.
        timer* operator[] ( unsigned int index );
    };
//-----------------------------------------------------------------------------
/// @brief Таймер.
class timer
    {
    public:
        /// @brief Состояние таймера.
        enum STATE
            {
            S_STOP = 0, ///< Не работает.
            S_WORK,     ///< Работает.
            S_PAUSE,    ///< Пауза.
            };

        /// @brief Запуск таймера.
        void start();

        /// @brief Сброс таймера.
        void reset();

        /// @brief Пауза таймера.
        void pause();

        /// @brief Проверка исхода времени таймера.
        ///
        /// @return true  - время вышло.
        /// @return false - время не вышло.
        bool is_time_up() const;

        /// @brief Получение времени работы таймера.
        ///
        /// @return - время работы таймера.
        unsigned long  get_work_time() const;

        /// @brief Установка задания таймера.
        ///
        /// @param new_countdown_time - задание.
        void set_countdown_time( unsigned long new_countdown_time );

        /// @brief Получение задания таймера.
        ///
        /// @return - задание таймера.
        unsigned long  get_countdown_time() const;

        /// @brief Получение состояния таймера.
        ///
        /// @return - состояние таймера.
        STATE get_state() const;

        timer();
    };
//-----------------------------------------------------------------------------
/// @brief Работа с сохраняемыми параметрами типа "дробное число".
///
/// Параметры сохраняются в энергонезависимой памяти.
class saved_params_float
    {
    public:
        /// @brief Сохранение значения @a value в параметр с номером @a idx
        /// в энергонезависимой памяти.
        ///
        /// @param idx   - индекс параметра.
        /// @param value - значение параметра.
        int save( unsigned int idx, float value );

        /// @brief Сохранение всех параметров в энергонезависимой памяти.
        int save_all();

        /// @brief Получение параметра по его номеру.
        ///
        /// При присваивании параметру нового значения (например par[ 5 ] = 6),
        /// параметр сохраняется только в оперативной памяти (не сохранит
        ///	значение после перезагрузки контроллера).
        ///
        /// @param idx   - индекс параметра.
        ///
        /// @return - параметр c заданным индексом.
        float& operator[] ( unsigned int idx );

        /// @brief Установка всех параметров в нулевое значение и сохранение
        /// в энергонезависимой памяти.
        void reset_to_0();
    };
//-----------------------------------------------------------------------------
/// @brief Работа с сохраняемыми параметрами типа "беззнаковое целое число".
///
/// Параметры сохраняются в энергонезависимой памяти.
class saved_params_u_int_4
    {
    public:
        /// @brief Сохранение значения @a value в параметр с номером @a idx
        /// в энергонезависимой памяти.
        int save( unsigned int idx, unsigned int value );

        /// @brief Сохранение всех параметров в энергонезависимой памяти.
        int save_all();

        /// @brief Получение параметра по его номеру.
        ///
        /// При присваивании параметру нового значения (например par[ 5 ] = 6),
        /// параметр сохраняется только в оперативной памяти (не сохранит
        ///	значение после перезагрузки контроллера).
        ///
        /// @param idx   - индекс параметра.
        ///
        /// @return - параметр c заданным индексом.
        unsigned int& operator[] ( unsigned int idx );

        /// @brief Установка всех параметров в нулевое значение и сохранение
        /// в энергонезависимой памяти.
        void reset_to_0();
    };
//-----------------------------------------------------------------------------
/// @brief Работа с рабочими параметрами типа "беззнаковое целое число".
///
/// Параметры сохраняются в оперативной памяти.
class run_time_params_u_int_4
    {
    public:
        /// @brief Получение параметра по его номеру.
        ///
        /// @param idx - индекс параметра.
        ///
        /// @return - параметр c заданным индексом.
        unsigned int& operator[] ( unsigned int idx );

        /// @brief Установка всех параметров в нулевое значение.
        void reset_to_0();
    };
//-----------------------------------------------------------------------------
/// @brief Работа с рабочими параметрами типа "дробное число".
///
/// Параметры сохраняются в оперативной памяти.
class run_time_params_float
    {
    public:
        /// @brief Получение параметра по его номеру.
        ///
        /// @param idx - индекс параметра.
        ///
        /// @return - параметр c заданным индексом.
        float& operator[] ( unsigned int idx );

        /// @brief Установка всех параметров в нулевое значение.
        void reset_to_0();
    };
//-----------------------------------------------------------------------------
/// @brief Работа с модулями ввода/вывода Wago.
///
/// Реализация чтения и записи состояний модулей ввода/вывода Wago.
class wago_manager
    {
    public:
        /// @brief Установка числа модулей.
        ///
        /// Вызывается из Lua.
        void init( int nodes_count );

        /// @brief Инициализация модуля Wago.
        ///
        /// Вызывается из Lua.
        void add_node( unsigned int index, int ntype, int address, char* IP_address, 
            int DO_cnt, int DI_cnt, int AO_cnt, int AO_size, 
            int AI_cnt, int AI_size );

        /// @brief Инициализация параметров канала аналогового вывода.
        ///
        /// Вызывается из Lua.
        void init_node_AO( unsigned int node_index, unsigned int AO_index,
            unsigned int type, unsigned int offset );

        /// @brief Инициализация параметров канала аналогового ввода.
        ///
        /// Вызывается из Lua.
        void init_node_AI( unsigned int node_index, unsigned int AI_index,
            unsigned int type, unsigned int offset );

    };
//-----------------------------------------------------------------------------
///@brief Получение менеджера Wago.
///
///@return Менеджер устройств проекта.
wago_manager* G_WAGO_MANAGER();
//-----------------------------------------------------------------------------
///@brief ПИД-регулятор.
///
///
class PID
    {
    public:

        ///@brief Основные сохраняемые параметры.
        enum PARAM
        {
        P_k = 0,               ///< Параметр k.
        P_Ti,                  ///< Параметр Ti.
        P_Td,                  ///< Параметр Td.
        P_dt,                  ///< Интервал расчёта
        P_max,                 ///< Мax значение входной величины.
        P_min,                 ///< Мin значение входной величины.
        P_acceleration_time,   ///< Время выхода на режим регулирования.
        P_is_manual_mode,      ///< Ручной режим.
        P_U_manual,            ///< Заданное ручное значение выходного сигнала.

        P_k2,                  ///< Параметр k2.
        P_Ti2,                 ///< Параметр Ti2.
        P_Td2,                 ///< Параметр Td2.
        };

        ///@brief Рабочие параметры.
        enum WORK_PARAM
        {
        WP_Z,  ///< Требуемое значение.
        WP_U,  ///< Выход ПИД.
        };

        /// @param n - номер.
        PID( int n );

        ///@brief Включение регулятора.
        void  on( char is_down_to_inaccel_mode = 0 );

        ///@brief Выключение регулятора.
        void  off();

        ///@brief Получение следующего значения выхода на основе текущего
        /// значения входа.
        float eval( float current_value, int delta_sign = 1 );

        ///@brief Задание новое задание ПИД.
        void  set( float new_z );

        /// @brief Получение задания ПИД.
        float get_assignment();

        /// @brief Запись сохраняемого параметра.
        void init_param( PARAM par_n, float val );

        /// @brief Запись рабочего параметра.
        void init_work_param( WORK_PARAM par_n, float val );

        /// @brief Запись сохраняемых параметров в EEPROM.
        void save_param();

        /// @brief Задание для использования дополнительных P_k2, P_Ti2, P_Td2.
        void  set_used_par ( int par_n );

        /// @brief Отладочная печать объекта в консоль.
        void print();
    };
//-----------------------------------------------------------------------------
class PAC_info: public i_Lua_save_device
    {
    public:
        int set_cmd( const char *prop, unsigned int idx, double val );
	};


PAC_info* G_PAC_INFO();
//-----------------------------------------------------------------------------
/// @brief Получение текущего времени в секундах.
///
/// @return Текущее время.
/// @warning Время возвращается в секундах с 01.01.1970, в 2038 произойдет 
/// переполнение.
unsigned long get_sec();
//-----------------------------------------------------------------------------
/// @brief Получение времени в миллисекундах.
///
/// Так как за 4 дня происходит переполнение и отсчет продолжается с 0, то для
/// вычисления разности времени использовать @ref get_delta_millisec.
///
/// @return Время с момента запуска программы в миллисекундах.
unsigned long get_millisec();
//-----------------------------------------------------------------------------
/// @brief Получение разности времени в миллисекундах.
///
/// @param time1     - начальное время.
/// @return Разность времени в миллисекундах.
unsigned long get_delta_millisec( unsigned long time1 );
//-----------------------------------------------------------------------------
/// @brief Ожидание заданное время.
///
/// @param ms - время ожидания, мс.
void sleep_ms( unsigned long ms );
