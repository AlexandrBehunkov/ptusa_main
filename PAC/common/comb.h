//ОБЩЕЕ ОПИСАНИЕ.
//  Содержит описание класса, который используются для хранения структуры 
//      гребенки и работы с ее режимами (маршрутами), заданными начальным 
//      и конечным элементом маршрута.
//
//ОПИСАНИЕ DEFINE.
//  PLC   - определяет компиляцию для контроллера.
//  WIN32 - определяет компиляцию для PC.

#ifndef _TCOMB_H_
#define _TCOMB_H_

#include "PAC_dev.h"
#include "param_ex.h"
#include "tech_def.h"
//-------------------------------------------------------------------------
//--Координаты точки.
struct comb_point
    {
    char x,y;
    int operator == ( comb_point p ) const 
        { 
        return ( x == p.x && y == p.y ); 
        }

    comb_point( char x = 0, char y = 0 ): x( x ), y( y )
        {
        }
    };
//-------------------------------------------------------------------------
//--Представление маршрута.
#define MAX_PATH_COUNT 20   //Максимальное число хранимых маршрутов

struct comb_path
    {
    enum PATH_TYPE
        {
        PT_STRAIGHT = 1,    //Прямой сквозной.
        PT_G_TYPE,          //Г-образный.
        };
    u_char     path_type;   //Тип маршрута.

    comb_point in;          //Точка входа.
    comb_point turn;        //Точка поворота.
    comb_point out;         //Точка выхода.
    comb_point in_;         //Точка, противоположная входу.
    comb_point out_;        //Точка, противоположная выходу.

    tech_object *object;        //Указатель на объект.
    int         object_mode_n;  //Номер режима объекта.
    u_int_4     start_time;     //Время включения маршрута.
    u_int_4     finish_time;    //Время отключения маршрута.

    comb_path():in( ( char ) -1, ( char ) -1 ),out( ( char ) -1, ( char ) -1 )
        {
        }
    };
//-------------------------------------------------------------------------
//--Элемент гребёнки.
struct comb_element
    {
    char type;			//Тип элемента
    unsigned int id;    //Идентификатор устройства
        
    // Статус элемента обновления. 
    enum CE_STATUS
        {        
        CES_NOT_USED,
        CES_USED,
        CES_MONOPOLY_USED,
        };    
    char status;

    unsigned int is_opened; // Флаг открытия ( 0 - оставить в данном положении; 1 - открыть )
    i_DO_device *valve;			//Указатель на клапан
    };
//-------------------------------------------------------------------------
//--Гребенка.
class comb
    {
    public:
        //-Для передачи данных в сервер.
        u_int_4   cmd;                //Команда.
        //complex_device  *com_dev;
        //-Для передачи данных в сервер.-!>

        enum COMB_PARAMS
            {
            CP_ERRORS,                  //Ошибки.
            CP_CONFLICTED_OBJECT1_TYPE, //Тип конфликтующего объекта 1.
            CP_CONFLICTED_OBJECT1_N,    //Номер конфликтующего объекта 1.
            CP_CONFLICTED_OBJECT2_TYPE, //Тип конфликтующего объекта 2.
            CP_CONFLICTED_OBJECT2_N,    //Номер конфликтующего объекта 2.
            CP_SWICTH_TIME,             //Время переключения режимов, мсек.
            };

        comb_path  *path_list;      // Таблица открытых маршрутов.
        comb_path	current_path;   // Текущий проверенный маршрут.

        char rows_cnt, columns_cnt; // Размеры матрицы: число строк/столбцов.
        char pathCount;             // Количество допустимых для открытия маршрутов.

        run_time_params_u_int_4 rt_par_uint;///< Рабочие параметры, тип u_int.

        comb_element** mMatrix;		// [rows_cnt][columns_cnt]. Матрица элементов гребенки.

        //	ОПИСАНИЕ:
        //		Конструктор. Устанавливает все элементы path_list и current_path в -1, выделяет
        //       память для хранения данных гребёнки.
        //	ПАРАМЕТРЫ:
        //		rows - число строк гребенки
        //		cols - число столбцов гребенки
        //
        comb( char rows, char cols );	

        //	ОПИСАНИЕ:
        //		Начальная инициализация переменных масивов и т.д.
        //		    
        void init();

        //	ОПИСАНИЕ:
        //		Проверка и открытие возможного маршрута.
        //	ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ:
        //		COMB_ERROR.
        //	ПАРАМЕТРЫ:
        //		[x1, y1] - координаты входного элемента гребенки
        //		[x2, y2] - координаты выходного элемента гребенки,
        //       [столбец, строка]
        //      object_type   - тип объекта, которому принадлежит маршрут;
        //      object        - указатель на объект;
        //      object_mode_n - номер режима объекта.
        //    
        int open_path( char x1, char y1, char x2, char y2,
            tech_object *object, int object_mode_n );

        //	ОПИСАНИЕ:
        //		Закрытие маршрута.
        //	ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ:
        //		COMB_ERROR.
        //	ПАРАМЕТРЫ:
        //		[x1, y1] - координаты входного элемента гребенки
        //		[x2, y2] - координаты выходного элемента гребенки,
        //    
        int close_path( char x1, char y1, char x2, char y2 );

        //	ОПИСАНИЕ:
        //		Проверка возможности маршрута и сохранение возможного маршрута.
        //	ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ:
        //		COMB_ERROR.
        //	ПАРАМЕТРЫ:
        //		[x1, y1] - координаты входного элемента гребенки
        //		[x2, y2] - координаты выходного элемента гребенки [столбец, строка]
        //
        int check_path( char x1, char y1, char x2, char y2 );

        //	ОПИСАНИЕ:
        //		В соответствие с текущей таблицей маршрутов
        //      окрывает/закрывает необходимые клапаны.
        //	ПАРАМЕТРЫ:
        //
        void refresh();    

        //	ОПИСАНИЕ:
        //      В зависимости от того прямой маршрут или угловой, вызывает Clipping
        //		с различными параметрами ( для того чтобы корректно отработал Clipping )
        //	ПАРАМЕТРЫ:
        //      baseX, baseY	- координаты поворота ( оси маршрута )
        //
    	void Clip( char baseY, char baseX );
    
    
        //	ОПИСАНИЕ:
        //		Проходим по осям маршрута ( baseX, baseY ) и закрываем отсечные клапана,
        //			чтобы продукт не попал куда не надо...
        //		При этом не происходит обновление всех клапанов, что позволяет работать с
        //			незадействованными клапанами в ручном режиме.
        //		Если встречается ответвление типа 23, 24, 25, 26, то мы делаем проверку
        //			и по этому ответвлению и закрываем отсечные клапана;
        // 	ПАРАМЕТРЫ:
        //      y, x - координаты углового элемента ( оси baseY и baseX );
        //      reg  - указывает по X или по Y производится проход;
        //      increment 		-	указывает направление прохода ( 1 или -1 );
        //		tube1 - tube5	-	трубы при встрече с которыми просмотр в данном
        //								направлении завершается;
        //
        void Clipping(	char y, char x, char reg, int increment,
                        int tube1, int tube2, int tube3, int tube4, int tube5 ); 

        //	ОПИСАНИЕ:
        //		Выводит на экран структуру и содержание объекта данного класса.
        //	ПАРАМЕТРЫ:
        //      type - если 1, то выводим на экран только статусы элементов гребенки.
        //
        void print( int type = 0 );

    private:
        enum COMB_ERROR
            {
            GE_OK = 0,              //  0 - Все ОК;
            GE_BLOCK_MODE = 2,      //  2 - Включен блокирующий режим;
            GE_PATH_ALREADY_USED,   //  3 - Маршрут уже используется (открыт);
            GE_INCORRECT_PATH,      //  4 - Маршрут задан не верно;
            GE_PATH_TABLE_IS_FULL,  //  5 - Нет свободной строки в таблице маршрутов;
            GE_IS_NOT_OPEN_PATH,    //  6 - Маршрута нет в списке открытых маршрутов.
            };

        //	ОПИСАНИЕ:
        //		Перечисление элементов гребенки.
        enum COMB_ELEMENT
            {
            COMB_NULL 	 	  	= 0,	//	Элемент отсутствует;
            COMB_T_VERTICAL		= 1,	//	Вертикальная труба;
            COMB_T_HORIZ	  	= 2,	//	Горизонтальная труба;
            COMB_T_HORIZ_UP		= 3,	//	Горизонтальная труба с ответвлением в верх;
            COMB_T_VERTIC_RIGHT	= 4,	//	Вертикальная труба с ответвлением в право;
            COMB_T_HORIZ_DOWN	= 5,	//	Горизонтальная труба с ответвлением в низ;
            COMB_T_VERTIC_LEFT	= 6,	//	Вертикальная труба с ответвлением в лево;
            COMB_T_CROSS_MIX	= 7,	//	Перекрестие труб со смешиванием;
            COMB_T_CROSS_SELF	= 8,    //	Перекрестие труб ( каждая сама по себе );
            COMB_STUB	 	  	= 9,	//	Заглушка;
            
            COMB_V_CLOSE	  	= 11,	//	Клапан отсечной нормально закрытый;
            COMB_V_OPEN			= 12,	//  Клапан отсечной нормально открытый;
            COMB_V_DRAIN_CLOSE	= 13,	//  Клапан дренажный нормально закрытый;
            COMB_V_DRAIN_OPEN 	= 14,	//  Клапан дренажный нормально открытый;
            COMB_V_MIX_PROOF  	= 15,	//  Клапан микспруф;
            
            COMB_TANK			= 21,	//  Танк;
            COMB_IN     		= 22,	//	Линия продукта;
            COMB_OUT	    	= 23,	//	Фасовочный автомат;
            COMB_MCA_IN	 	  	= 24,	//	Вход мойки;
            COMB_MCA_OUT		= 25,	//	Выход мойки;
            COMB_DRAINAGE		= 26,	//	Канализация (дренаж);
            COMB_WATER  		= 27,	//	Сетевая вода;
            COMB_POST			= 28	//	Пост;            
            };

        //	ОПИСАНИЕ:
        //      Помечает используемые клапана маршрута.
        //      В зависимости от того прямой маршрут или угловой, вызывает mark_path_elements
        //		с различными параметрами.
        //	ПАРАМЕТРЫ:
        //      marked_path - маршрут;
        //      is_unmark   - убрать отметку с элементов маршрута (при отключении).
        //
        void mark_path( comb_path *marked_path, char is_unmark = 0 ); 

        //	ОПИСАНИЕ:
        //		Проходим по отрезку [ x1, y1 ] - [ x2, y2 ] и помечаем(снимаем отметку)
        //      используемые клапана. Открываем (закрываем) отсечные клапана.
        // 	ПАРАМЕТРЫ:
        //      x1, y1      - координаты начала отрезка;
        //      x2, y2      - координаты конца отрезка;
        //      is_open     - открывать ли отсечные клапана;
        //      is_unmark   - снимать ли отметку о использовании клапанов.
        //
        int mark_path_elements( char x1, char y1, char x2, char y2, 
            char is_open, char is_unmark = 0 );

        //	ОПИСАНИЕ:
        //  	Находит координаты начала и конца отрезков, из которых состоит маршрут.
        //	ПАРАМЕТРЫ:
        //      in	- точка входа;
        //		out	- точка выхода;
        //
        int get_path_points( comb_point in, comb_point out );

        //	ОПИСАНИЕ:
        //  	Находит используемые блокирующие клапана.
        // 	ПАРАМЕТРЫ:
        //      x1, y1  - точка входа;
        //		x2, y2  - точка выхода;
        //      is_open - если 1, то ищем открытые отсечные клапана;
        //
        int find_block_element( char x1, char y1, char x2, char y2, char is_open );       
        
    };	 
#endif
