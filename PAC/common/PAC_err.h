/// @file PAC_err.h
/// @brief Содержит описания классов, которые используются для организации
/// работы с критическими ошибками PAC.
///
/// Класс @ref PAC_critical_errors_manager, служащий для организации работы с
/// ошибками простых устройств, содержит всю необходимую информацию. Для сбора
/// всех ошибок служит структура @ref PAC_critical_errors_manager::critical_error.
///
/// @author  Иванюк Дмитрий Сергеевич.
///
/// @par Описание директив препроцессора:
/// @c PAC_ERRORS_H - включение данного файла в компиляцию только один раз.@n
///
/// @par Текущая версия:
/// @$Rev$.\n
/// @$Author$.\n
/// @$Date::                     $.

#ifndef PAC_ERRORS_H
#define PAC_ERRORS_H

#include <string.h>
#include <vector>

#include "errors.h"
#include "smart_ptr.h"
#include "dtime.h"
#include "led.h"

//-----------------------------------------------------------------------------
//0, 1, n - нет связи с узлом Wago номер n.
//0, 2, n - нет связи с панелью номер n.
//0, 3, n - нет связи с Modbus устройством номер n.
//0, 4, 4 -
//0, 5, 5 - нет связи с сервером.
//
//1, 1 - ошибка работы с COM-портом WAGO.
//      1 - CRC error
//
//13 - ошибки времени работы:
//  1, n  - нажата аварийная кнопка номер n.
//-----------------------------------------------------------------------------
class PAC_critical_errors_manager
    {
    public:
        enum CONSTANTS
            {
            ALARM_CLASS_PRIORITY = 100,
            };

        enum ALARM_CLASS      ///< Класс тревоги.
            {
            AC_UNKNOWN,
            AC_NO_CONNECTION, ///< Ошибка связи.

            AC_COM_DRIVER,    ///< Ошибка работы с COM-портом.
            AC_RUNTIME_ERROR, ///< Ошибки во время работы.
            };

        enum ALARM_SUBCLASS         ///< Подкласс тревоги.
            {
            //AC_NO_CONNECTION,     ///< Ошибка связи.
            AS_WAGO = 1,            ///< Ошибки модулей WAGO.
            AS_PANEL,               ///< Ошибки панелей EasyView.
            AS_MODBUS_DEVICE,       ///< Ошибки устройства, опрашиваемого по Modbus.

            AS_EASYSERVER = 5,      ///< Ошибки EasyServer.
            AS_REMOTE_PAC,          ///< Ошибки связи с удаленным PAC.

            //AC_RUNTIME_ERROR,     ///< Ошибки во время работы.
            AS_EMERGENCY_BUTTON = 1,///< Нажата аварийная кнопка.
            };

    public:
        enum GE_CONST
            {
            GE_ERROR_SIZE = 3,      ///< Размер одной ошибки, байт.
            };

        PAC_critical_errors_manager();

        void show_errors();
        void set_global_error( ALARM_CLASS eclass, ALARM_SUBCLASS p1,
            unsigned long param );
        void reset_global_error( ALARM_CLASS eclass, ALARM_SUBCLASS p1,
            unsigned long param );

        int save_as_Lua_str( char *str, u_int_2 &id );

        static PAC_critical_errors_manager * get_instance();

        u_int get_id() const
            {
            return errors_id;
            }

    private:
        const char* get_alarm_group()
            {
            return "Авария";
            }

        const char* get_alarm_descr( ALARM_CLASS err_class, ALARM_SUBCLASS err_sub_class, int par )
            {
            static char tmp[ 100 ] = "";

            switch( err_class )
                {
            case AC_UNKNOWN:
                return "?";

            case AC_NO_CONNECTION:
                switch( err_sub_class )
                    {
                case AS_WAGO:
                    snprintf( tmp, sizeof( tmp ), "Нет связи с узлом Wago №%d", par );
                    return tmp;

                case AS_PANEL:
                    snprintf( tmp, sizeof( tmp ), "Нет связи с панелью EasyView №%d", par );
                    return tmp;

                case AS_MODBUS_DEVICE:
                    snprintf( tmp, sizeof( tmp ), "Нет связи с устройством, опрашиваемое по Modbus, №%d", par );
                    return tmp;

                case AS_EASYSERVER:
                    return "EasyServer";

                case AS_REMOTE_PAC:
                    return "Remote PAC";
                    }//switch( err_sub_class )
                break;

            case AC_COM_DRIVER:
                return "?";
                break;

            case AC_RUNTIME_ERROR:
                switch( err_sub_class )
                    {
                case AS_EMERGENCY_BUTTON:
                    snprintf( tmp, sizeof( tmp ), "нажата аварийная кнопка №%d", par );
                    return tmp;

                default:
                    return "?";
                    }// switch( err_sub_class )
                }// switch( err_class )

            return "?";
            }

        static auto_smart_ptr < PAC_critical_errors_manager > instance;

        struct critical_error
            {
            int             err_class;     ///< Класс ошибки.
            unsigned int    err_sub_class; ///< Подкласс ошибки.
            unsigned int    param;         ///< Параметр ошибки.

            critical_error( int err_class = 0, u_int err_sub_class = 0,
                u_int param = 0 );
            };

        std::vector< critical_error >  errors;

        u_int_2 errors_id;
        int     global_ok;
    };
//-----------------------------------------------------------------------------
#endif // PAC_ERRORS_H
