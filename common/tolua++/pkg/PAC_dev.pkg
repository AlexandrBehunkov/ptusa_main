$#include <stdlib.h>

$#include "PAC_dev.h"
$#include "tech_def.h"
$#include "tolua_base.h"

//-----------------------------------------------------------------------------
/// @brief Устройство с дискретным входом.
///
/// Устройства типа обратной связи, уровня и т.д. реализуют данный интерфейс.
class i_DI_device
    {
    public:           
        virtual ~i_DI_device();
        
        i_DI_device();

        /// @brief Получение текущего состояния устройства.
        ///
        /// @return - текущее состояние устройства в виде целого числа.
        virtual int get_state_now() = 0;

        /// @brief Получение текущего состояния устройства.
        ///
        /// @return - текущее состояние устройства в виде целого числа.
        virtual int get_state();

        /// @brief Установка времени ожидания изменения состояния.
        ///
        /// @param time - время ожидания изменения состояния.
        void set_dt( unsigned int time );

        /// @brief Установка состояния.
        ///
        /// @param new_state - новое состояние.
        void set_st_state( int new_state );
    };
//-----------------------------------------------------------------------------
/// @brief Устройство с дискретным выходом.
///
/// Устройства типа клапана, мешалки и т.д. реализуют данный интерфейс.
class i_DO_device: public i_DI_device
    {
    public:     
        virtual ~i_DO_device();  
        
        /// @brief Включение устройства.
        ///
        /// Установка устройства в активное состояние. Для клапана это означает
        /// его активирование, то есть если он нормально закрытый - открытие.
        virtual void on() = 0;

        /// @brief Выключение устройства.
        ///
        /// Установка устройства в пассивное состояние. Для клапана это означает
        /// его деактивирование, то есть если он нормально закрытый - закрытие.
        virtual void off() = 0;

        /// @brief Установка нового состояния устройства.
        ///
        /// @param new_state - новое состояние объекта.
        ///
        /// @return -  0 - Ок.
        /// @return - >0 - ошибка.
        virtual int set_state( int new_state ) = 0;
    };
//-----------------------------------------------------------------------------
/// @brief Устройство с аналоговым входом.
///
/// Устройства типа температуры, расхода и т.д. реализуют данный интерфейс.
class i_AI_device
    {
    public:
        /// @brief Получение текущего состояния устройства.
        ///
        /// @return - текущее состояние устройства в виде дробного числа.
        virtual float get_value() = 0;
    };
//-----------------------------------------------------------------------------
/// @brief Устройство с аналоговым выходом.
///
/// Устройства типа аналогового каналы управления и т.д. реализуют данный
/// интерфейс.
class i_AO_device: public i_AI_device
    {
    public:
        /// @brief Выключение устройства.
        ///
        /// Установка устройства в пассивное состояние. Для клапана это означает
        /// его деактивирование, то есть если он нормально закрытый - закрытие.
        virtual void off() = 0;

        /// @brief Установка текущего состояния устройства.
        ///
        /// @param new_value - новое состояние устройства.
        ///
        /// @return -  0 - Ок.
        /// @return - >0 - ошибка.
        virtual int set_value( float new_value ) = 0;
    };
//-----------------------------------------------------------------------------
/// @brief Интерфейс счетчика.
class i_counter
    {
    public:
        /// @brief Приостановка работы счетчика.
        virtual void pause() = 0;

        /// @brief Возобновление работы счетчика.
        virtual void start() = 0;

        /// @brief Сброс счетчика.
        /// 
        /// После сброса для продолжения работы необходимо вызвать @ref start().
        virtual void reset() = 0;

        /// @brief Получение значения счетчика.
        virtual unsigned long get_quantity() = 0;
    }
//-----------------------------------------------------------------------------     
i_DO_device* V( int number );
//-----------------------------------------------------------------------------
i_DO_device* N( int number );
//-----------------------------------------------------------------------------
i_DO_device* M( int number );   ///< Получение мешалки по номеру.
//-----------------------------------------------------------------------------
i_DI_device* LS( int number );  ///< Получение сигнального уровня по номеру.
//-----------------------------------------------------------------------------
i_DI_device* FS( int number );  ///< Получение сигнального расхода по номеру.
//-----------------------------------------------------------------------------
i_AI_device* AI( int number );  ///< Получение аналогового входа по номеру.
//-----------------------------------------------------------------------------
i_AO_device* AO( int number );  ///< Получение аналогового выхода по номеру.
//-----------------------------------------------------------------------------
i_counter* CTR( int number );   ///< Получение счетчика по номеру.
//-----------------------------------------------------------------------------
i_AI_device* TE( int number );  ///< Получение температуры по номеру.
//-----------------------------------------------------------------------------
i_AI_device* FE( int number );  ///< Получение текущего расхода по номеру.
//-----------------------------------------------------------------------------
i_AI_device* LE( int number );  ///< Получение текущего уровня по номеру.
//-----------------------------------------------------------------------------
i_DI_device* FB( int number );  ///< Получение обратной связи по номеру.
//-----------------------------------------------------------------------------
i_DO_device* UPR( int number ); ///< Получение канала управления по номеру.
//-----------------------------------------------------------------------------
i_AI_device* QE( int number );  ///< Получение текущей концентрации по номеру.
//-----------------------------------------------------------------------------
dev_stub* STUB();
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
/// @brief Виртуальное устройство.
///
/// Необходимо для возвращения результата поиска устройства с несуществующим
/// номером. Методы данного класса ничего не делают. 
class dev_stub
    {
    public:
        float   get_value();
        int     set_value( float new_value );                

        void    on();                
        void    off();                
        int     set_state( int new_state );
        int     get_state_now();

        void    pause();
        void    start();
        void    reset();
        u_int   get_quantity();
    };
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
class tech_object 
    {
    public:
        /// @param name                     - название (tank, comb).
        /// @param number                   - номер.
        /// @param states_count             - количество режимов.
        /// @param timers_count             - количество таймеров.
        /// @param par_float_count          - количество сохраняемых параметров типа float.
        /// @param runtime_par_float_count  - количество рабочих параметров типа float.
        /// @param par_uint_count           - количество сохраняемых параметров типа uint.
        /// @param runtime_par_uint_count   - количество рабочих параметров типа uint.
        tech_object( const char* name = "tech_object", unsigned int number = 0,
            unsigned int states_count = 1,
            unsigned int timers_count = 3,
            unsigned int par_float_count = 5, unsigned int runtime_par_float_count = 5,
            unsigned int par_uint_count = 5, unsigned int runtime_par_uint_count = 5 );

        virtual ~tech_object();

        /// @brief Включение/выключение режима.
        ///
        /// @param mode      - режим.
        /// @param new_state - новое состояние режима.
        virtual int set_mode( unsigned int mode, int new_state );

        /// @brief Получение состояния режима.
        ///
        /// @param mode - режим.
        ///
        /// @return 1 - режим включен.
        /// @return 0 - режим не включен.
        int get_mode( unsigned int mode );

        /// @brief Проверка возможности включения режима.
        ///
        /// Если данный метод возвращает 1, то тогда режим не включается.
        ///
        /// @param mode - режим.
        ///
        /// @return 1 - режим нельзя включить.
        /// @return 0 - режим можно включить.
        virtual int check_on_mode( unsigned int mode );

        /// @brief Выполнение команды.
        ///
        /// Здесь могут выполняться какие-либо действия (включаться/выключаться
        /// другие режимы).
        ///
        virtual int exec_cmd( unsigned int cmd );

        /// @brief Инициализация режима.
        ///
        /// При инициализации режима выполнение нужных действий -
        /// включение маршрута, включение/выключение клапанов и т.д.
        ///
        /// @param mode - режим.
        virtual void init_mode( unsigned int mode );

        /// @brief Выполнение включенных режимов.
        ///
        /// При активном режиме выполнение нужных действий -
        /// обновление маршрута, включение/выключение клапанов и т.д.
        ///
        /// @return 0 - ок.
        virtual int evaluate();

        /// @brief Проверка возможности выключения режима.
        ///
        /// @param mode - режим.
        ///
        /// @return 1 - режим нельзя выключить.
        /// @return 0 - режим можно выключить.
        virtual int check_off_mode( unsigned int mode );

        /// @brief Завершение режима.
        ///
        /// При завершении режима выполнение нужных действий -
        /// выключение маршрута, включение/выключение клапанов и т.д.
        ///
        /// @param mode - режим.
        ///
        /// @return 0 - ок.
        virtual int final_mode( unsigned int mode );

        int get_number() const;

        unsigned int get_modes_count() const;

        saved_params_float      par_float;      ///< Сохраняемые параметры, тип float.
        run_time_params_float   rt_par_float;   ///< Рабочие параметры, тип float.
        saved_params_u_int_4    par_uint;       ///< Сохраняемые параметры, тип unsigned int.
        run_time_params_u_int_4 rt_par_uint;    ///< Рабочие параметры, тип unsigned int.

        timer_manager           timers;			///< Таймеры объекта.
    };
//-----------------------------------------------------------------------------
tech_object_manager* G_TECH_OBJECT_MNGR();
//-----------------------------------------------------------------------------
tech_object* G_TECH_OBJECTS( unsigned int idx );
//-----------------------------------------------------------------------------
class tech_object_manager
    {
    public:
        /// @brief Получение объекта с заданным активным режимом.
        int get_object_with_active_mode( unsigned int mode, 
            unsigned int start_idx, unsigned int end_idx );

        /// @brief Получение объекта по номеру.
        tech_object* get_tech_objects( unsigned int idx );

        /// @brief Получение количества объектов.
        unsigned int get_count() const;     
    };   
//-----------------------------------------------------------------------------
device_manager* G_DEVICE_MANAGER();
//-----------------------------------------------------------------------------    
/// @brief Менеджер устройств.
///
/// Содержит информацию обо всех устройствах проекта.
class device_manager
    {
    public:
        /// @brief Отладочная печать объекта в консоль.
        void print() const;
    }	
//-----------------------------------------------------------------------------
/// @brief Таймер.
///
/// Реализация группы таймеров.
class timer_manager
    {
    public:
        /// @brief Безопасное получение таймера по индексу.
        ///
        /// @param index - индекс таймера.
        ///
        /// @return - таймер с нужным индексом, заглушка - в случае выхода за 
        /// диапазон.
        timer& operator[] ( unsigned int index );
    };	
//-----------------------------------------------------------------------------	  
class timer
    {
    public:
        enum STATE
            {
            S_STOP = 0, ///< Не работает.
            S_WORK,     ///< Работает.
            S_PAUSE,    ///< Пауза.
            };

        /// @brief Запуск таймера.
        void start();

        /// @brief Сброс таймера.
        void reset();

        /// @brief Пауза таймера.
        void pause();

        /// @brief Проверка исхода времени таймера.
        ///
        /// @return 1 - время вышло.
        /// @return 0 - время не вышло.
        bool is_time_up() const;

        /// @brief Получение времени работы таймера.
        ///
        /// @return - время работы таймера.
        unsigned long  get_work_time() const;

        /// @brief Установка задания таймера.
        ///
        /// @param new_countdown_time - задание.
        void set_countdown_time( unsigned long new_countdown_time );

        /// @brief Получение задания таймера.
        ///
        /// @return - задание таймера.
        unsigned long  get_countdown_time() const;

        /// @brief Получение состояния таймера.
        ///
        /// @return - состояние таймера.
        STATE get_state() const;
    };
//-----------------------------------------------------------------------------
class saved_params_float
    {
    public:
        /// @brief Конструктор.
        ///
        /// @param count - количество параметров.
        saved_params_float( int count );

        virtual ~saved_params_float();

        /// @brief Реализация интерфейса класса @ref array_device.
        int save( unsigned int idx, float value );
        
        int save_all();  

        float& operator[] ( unsigned int index );
        
        void reset_to_0();
    };
//-----------------------------------------------------------------------------
class saved_params_u_int_4
    {
    public:
        /// @brief Конструктор.
        ///
        /// @param count - количество параметров.
        saved_params_u_int_4( int count );

        virtual ~saved_params_u_int_4();

        /// @brief Реализация интерфейса класса @ref array_device.
        int save( unsigned int idx, unsigned int value );
        
        int save_all();  

        unsigned int& operator[] ( unsigned int index );
        
        void reset_to_0();
    }; 
    //-----------------------------------------------------------------------------
class run_time_params_u_int_4
    {
    public:
        /// @brief Конструктор.
        ///
        /// @param count - количество параметров.
        run_time_params_u_int_4( int count );

        virtual ~run_time_params_u_int_4();
        
        unsigned int& operator[] ( unsigned int index );

        void reset_to_0();
    }; 
//-----------------------------------------------------------------------------
class run_time_params_float
    {
    public:
        /// @brief Конструктор.
        ///
        /// @param count - количество параметров.
        run_time_params_float( int count );

        virtual ~run_time_params_float();
        
        float& operator[] ( unsigned int index );

        void reset_to_0();
    };
//-----------------------------------------------------------------------------